// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: config/chain_config.proto

package config

import (
	accesscontrol "chainmaker.org/chainmaker-go/pb/protogo/accesscontrol"
	common "chainmaker.org/chainmaker-go/pb/protogo/common"
	consensus "chainmaker.org/chainmaker-go/pb/protogo/consensus"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ChainConfig
type ChainConfig struct {
	// blockchain identifier
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// blockchain version
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// authentication type
	AuthType string `protobuf:"bytes,3,opt,name=auth_type,json=authType,proto3" json:"auth_type,omitempty"`
	// config sequence
	Sequence uint64 `protobuf:"varint,4,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// encryption algorithm related configuration
	Crypto *CryptoConfig `protobuf:"bytes,5,opt,name=crypto,proto3" json:"crypto,omitempty"`
	// block related configuration
	Block *BlockConfig `protobuf:"bytes,6,opt,name=block,proto3" json:"block,omitempty"`
	// core module related configuration
	Core *CoreConfig `protobuf:"bytes,7,opt,name=core,proto3" json:"core,omitempty"`
	// consensus related configuration
	Consensus *ConsensusConfig `protobuf:"bytes,8,opt,name=consensus,proto3" json:"consensus,omitempty"`
	// trusted root related configuration
	// for alliance members, the initial member's root info of the consortium; for public chain, there is no need to configure
	// Key: node_id; value: address, node public key / CA certificate
	TrustRoots []*TrustRootConfig `protobuf:"bytes,9,rep,name=trust_roots,json=trustRoots,proto3" json:"trust_roots,omitempty"`
	// trusted member related configuration
	// for compatible other ca certs
	TrustMembers []*TrustMemberConfig `protobuf:"bytes,10,rep,name=trust_members,json=trustMembers,proto3" json:"trust_members,omitempty"`
	// permission related configuration
	ResourcePolicies []*ResourcePolicy `protobuf:"bytes,11,rep,name=resource_policies,json=resourcePolicies,proto3" json:"resource_policies,omitempty"`
	Contract         *ContractConfig   `protobuf:"bytes,12,opt,name=contract,proto3" json:"contract,omitempty"`
	// snapshot module related configuration
	Snapshot *SnapshotConfig `protobuf:"bytes,13,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	// scheduler module related configuration
	Scheduler *SchedulerConfig `protobuf:"bytes,14,opt,name=scheduler,proto3" json:"scheduler,omitempty"`
	// tx sim context module related configuration
	Context *ContextConfig `protobuf:"bytes,15,opt,name=context,proto3" json:"context,omitempty"`
}

func (m *ChainConfig) Reset()         { *m = ChainConfig{} }
func (m *ChainConfig) String() string { return proto.CompactTextString(m) }
func (*ChainConfig) ProtoMessage()    {}
func (*ChainConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{0}
}
func (m *ChainConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainConfig.Merge(m, src)
}
func (m *ChainConfig) XXX_Size() int {
	return m.Size()
}
func (m *ChainConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ChainConfig proto.InternalMessageInfo

func (m *ChainConfig) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *ChainConfig) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ChainConfig) GetAuthType() string {
	if m != nil {
		return m.AuthType
	}
	return ""
}

func (m *ChainConfig) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *ChainConfig) GetCrypto() *CryptoConfig {
	if m != nil {
		return m.Crypto
	}
	return nil
}

func (m *ChainConfig) GetBlock() *BlockConfig {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *ChainConfig) GetCore() *CoreConfig {
	if m != nil {
		return m.Core
	}
	return nil
}

func (m *ChainConfig) GetConsensus() *ConsensusConfig {
	if m != nil {
		return m.Consensus
	}
	return nil
}

func (m *ChainConfig) GetTrustRoots() []*TrustRootConfig {
	if m != nil {
		return m.TrustRoots
	}
	return nil
}

func (m *ChainConfig) GetTrustMembers() []*TrustMemberConfig {
	if m != nil {
		return m.TrustMembers
	}
	return nil
}

func (m *ChainConfig) GetResourcePolicies() []*ResourcePolicy {
	if m != nil {
		return m.ResourcePolicies
	}
	return nil
}

func (m *ChainConfig) GetContract() *ContractConfig {
	if m != nil {
		return m.Contract
	}
	return nil
}

func (m *ChainConfig) GetSnapshot() *SnapshotConfig {
	if m != nil {
		return m.Snapshot
	}
	return nil
}

func (m *ChainConfig) GetScheduler() *SchedulerConfig {
	if m != nil {
		return m.Scheduler
	}
	return nil
}

func (m *ChainConfig) GetContext() *ContextConfig {
	if m != nil {
		return m.Context
	}
	return nil
}

// specific permission configuration structure
type ResourcePolicy struct {
	// resource name
	ResourceName string `protobuf:"bytes,1,opt,name=resource_name,json=resourceName,proto3" json:"resource_name,omitempty"`
	// policy(permission)
	Policy *accesscontrol.Policy `protobuf:"bytes,2,opt,name=policy,proto3" json:"policy,omitempty"`
}

func (m *ResourcePolicy) Reset()         { *m = ResourcePolicy{} }
func (m *ResourcePolicy) String() string { return proto.CompactTextString(m) }
func (*ResourcePolicy) ProtoMessage()    {}
func (*ResourcePolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{1}
}
func (m *ResourcePolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourcePolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourcePolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourcePolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourcePolicy.Merge(m, src)
}
func (m *ResourcePolicy) XXX_Size() int {
	return m.Size()
}
func (m *ResourcePolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourcePolicy.DiscardUnknown(m)
}

var xxx_messageInfo_ResourcePolicy proto.InternalMessageInfo

func (m *ResourcePolicy) GetResourceName() string {
	if m != nil {
		return m.ResourceName
	}
	return ""
}

func (m *ResourcePolicy) GetPolicy() *accesscontrol.Policy {
	if m != nil {
		return m.Policy
	}
	return nil
}

// encryption configuration
type CryptoConfig struct {
	// enable Transaction timestamp verification or Not
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *CryptoConfig) Reset()         { *m = CryptoConfig{} }
func (m *CryptoConfig) String() string { return proto.CompactTextString(m) }
func (*CryptoConfig) ProtoMessage()    {}
func (*CryptoConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{2}
}
func (m *CryptoConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CryptoConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CryptoConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CryptoConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CryptoConfig.Merge(m, src)
}
func (m *CryptoConfig) XXX_Size() int {
	return m.Size()
}
func (m *CryptoConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CryptoConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CryptoConfig proto.InternalMessageInfo

func (m *CryptoConfig) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

// elockConfig
type BlockConfig struct {
	// enable transaction timestamp verification or Not
	TxTimestampVerify bool `protobuf:"varint,1,opt,name=tx_timestamp_verify,json=txTimestampVerify,proto3" json:"tx_timestamp_verify,omitempty"`
	// expiration time of transaction timestamp (seconds)
	TxTimeout uint32 `protobuf:"varint,2,opt,name=tx_timeout,json=txTimeout,proto3" json:"tx_timeout,omitempty"`
	// maximum number of transactions in a block
	BlockTxCapacity uint32 `protobuf:"varint,3,opt,name=block_tx_capacity,json=blockTxCapacity,proto3" json:"block_tx_capacity,omitempty"`
	// maximum block size, in MB
	BlockSize uint32 `protobuf:"varint,4,opt,name=block_size,json=blockSize,proto3" json:"block_size,omitempty"`
	// block proposing interval, in ms
	BlockInterval uint32 `protobuf:"varint,5,opt,name=block_interval,json=blockInterval,proto3" json:"block_interval,omitempty"`
}

func (m *BlockConfig) Reset()         { *m = BlockConfig{} }
func (m *BlockConfig) String() string { return proto.CompactTextString(m) }
func (*BlockConfig) ProtoMessage()    {}
func (*BlockConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{3}
}
func (m *BlockConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockConfig.Merge(m, src)
}
func (m *BlockConfig) XXX_Size() int {
	return m.Size()
}
func (m *BlockConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockConfig.DiscardUnknown(m)
}

var xxx_messageInfo_BlockConfig proto.InternalMessageInfo

func (m *BlockConfig) GetTxTimestampVerify() bool {
	if m != nil {
		return m.TxTimestampVerify
	}
	return false
}

func (m *BlockConfig) GetTxTimeout() uint32 {
	if m != nil {
		return m.TxTimeout
	}
	return 0
}

func (m *BlockConfig) GetBlockTxCapacity() uint32 {
	if m != nil {
		return m.BlockTxCapacity
	}
	return 0
}

func (m *BlockConfig) GetBlockSize() uint32 {
	if m != nil {
		return m.BlockSize
	}
	return 0
}

func (m *BlockConfig) GetBlockInterval() uint32 {
	if m != nil {
		return m.BlockInterval
	}
	return 0
}

// Scheduler configuration
type SchedulerConfig struct {
	// for evidence constract
	EnableEvidence bool `protobuf:"varint,1,opt,name=enable_evidence,json=enableEvidence,proto3" json:"enable_evidence,omitempty"`
}

func (m *SchedulerConfig) Reset()         { *m = SchedulerConfig{} }
func (m *SchedulerConfig) String() string { return proto.CompactTextString(m) }
func (*SchedulerConfig) ProtoMessage()    {}
func (*SchedulerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{4}
}
func (m *SchedulerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedulerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedulerConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedulerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulerConfig.Merge(m, src)
}
func (m *SchedulerConfig) XXX_Size() int {
	return m.Size()
}
func (m *SchedulerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulerConfig proto.InternalMessageInfo

func (m *SchedulerConfig) GetEnableEvidence() bool {
	if m != nil {
		return m.EnableEvidence
	}
	return false
}

// Snapshot configuration
type SnapshotConfig struct {
	// for the evidence contract
	EnableEvidence bool `protobuf:"varint,1,opt,name=enable_evidence,json=enableEvidence,proto3" json:"enable_evidence,omitempty"`
}

func (m *SnapshotConfig) Reset()         { *m = SnapshotConfig{} }
func (m *SnapshotConfig) String() string { return proto.CompactTextString(m) }
func (*SnapshotConfig) ProtoMessage()    {}
func (*SnapshotConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{5}
}
func (m *SnapshotConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotConfig.Merge(m, src)
}
func (m *SnapshotConfig) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotConfig proto.InternalMessageInfo

func (m *SnapshotConfig) GetEnableEvidence() bool {
	if m != nil {
		return m.EnableEvidence
	}
	return false
}

// TxSimContext configuration
type ContextConfig struct {
	// for the evidence contract
	EnableEvidence bool `protobuf:"varint,1,opt,name=enable_evidence,json=enableEvidence,proto3" json:"enable_evidence,omitempty"`
}

func (m *ContextConfig) Reset()         { *m = ContextConfig{} }
func (m *ContextConfig) String() string { return proto.CompactTextString(m) }
func (*ContextConfig) ProtoMessage()    {}
func (*ContextConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{6}
}
func (m *ContextConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContextConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContextConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContextConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContextConfig.Merge(m, src)
}
func (m *ContextConfig) XXX_Size() int {
	return m.Size()
}
func (m *ContextConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ContextConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ContextConfig proto.InternalMessageInfo

func (m *ContextConfig) GetEnableEvidence() bool {
	if m != nil {
		return m.EnableEvidence
	}
	return false
}

// core module related configuration
type CoreConfig struct {
	// [0, 60], the time when the transaction scheduler gets the transaction from the transaction pool to schedule
	TxSchedulerTimeout uint64 `protobuf:"varint,1,opt,name=tx_scheduler_timeout,json=txSchedulerTimeout,proto3" json:"tx_scheduler_timeout,omitempty"`
	// [0, 60], the time-out for verification after the transaction scheduler obtains the transaction from the block
	TxSchedulerValidateTimeout uint64 `protobuf:"varint,2,opt,name=tx_scheduler_validate_timeout,json=txSchedulerValidateTimeout,proto3" json:"tx_scheduler_validate_timeout,omitempty"`
}

func (m *CoreConfig) Reset()         { *m = CoreConfig{} }
func (m *CoreConfig) String() string { return proto.CompactTextString(m) }
func (*CoreConfig) ProtoMessage()    {}
func (*CoreConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{7}
}
func (m *CoreConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoreConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoreConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoreConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoreConfig.Merge(m, src)
}
func (m *CoreConfig) XXX_Size() int {
	return m.Size()
}
func (m *CoreConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CoreConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CoreConfig proto.InternalMessageInfo

func (m *CoreConfig) GetTxSchedulerTimeout() uint64 {
	if m != nil {
		return m.TxSchedulerTimeout
	}
	return 0
}

func (m *CoreConfig) GetTxSchedulerValidateTimeout() uint64 {
	if m != nil {
		return m.TxSchedulerValidateTimeout
	}
	return 0
}

// consensus module related configuration
type ConsensusConfig struct {
	// consensus type
	Type consensus.ConsensusType `protobuf:"varint,1,opt,name=type,proto3,enum=consensus.ConsensusType" json:"type,omitempty"`
	// organization list of nodes
	Nodes []*OrgConfig `protobuf:"bytes,2,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// expand the field, record the difficulty, reward and other consensus algorithm configuration
	ExtConfig []*common.KeyValuePair `protobuf:"bytes,3,rep,name=ext_config,json=extConfig,proto3" json:"ext_config,omitempty"`
}

func (m *ConsensusConfig) Reset()         { *m = ConsensusConfig{} }
func (m *ConsensusConfig) String() string { return proto.CompactTextString(m) }
func (*ConsensusConfig) ProtoMessage()    {}
func (*ConsensusConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{8}
}
func (m *ConsensusConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusConfig.Merge(m, src)
}
func (m *ConsensusConfig) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusConfig proto.InternalMessageInfo

func (m *ConsensusConfig) GetType() consensus.ConsensusType {
	if m != nil {
		return m.Type
	}
	return consensus.ConsensusType_SOLO
}

func (m *ConsensusConfig) GetNodes() []*OrgConfig {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *ConsensusConfig) GetExtConfig() []*common.KeyValuePair {
	if m != nil {
		return m.ExtConfig
	}
	return nil
}

// organization related configuration
type OrgConfig struct {
	// organization identifier
	OrgId string `protobuf:"bytes,1,opt,name=org_id,json=orgId,proto3" json:"org_id,omitempty"`
	// address list owned by the organization
	// Deprecated , replace by node_id
	Address []string `protobuf:"bytes,2,rep,name=address,proto3" json:"address,omitempty"`
	// node id list owned by the organization
	NodeId []string `protobuf:"bytes,3,rep,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *OrgConfig) Reset()         { *m = OrgConfig{} }
func (m *OrgConfig) String() string { return proto.CompactTextString(m) }
func (*OrgConfig) ProtoMessage()    {}
func (*OrgConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{9}
}
func (m *OrgConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrgConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrgConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrgConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrgConfig.Merge(m, src)
}
func (m *OrgConfig) XXX_Size() int {
	return m.Size()
}
func (m *OrgConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_OrgConfig.DiscardUnknown(m)
}

var xxx_messageInfo_OrgConfig proto.InternalMessageInfo

func (m *OrgConfig) GetOrgId() string {
	if m != nil {
		return m.OrgId
	}
	return ""
}

func (m *OrgConfig) GetAddress() []string {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *OrgConfig) GetNodeId() []string {
	if m != nil {
		return m.NodeId
	}
	return nil
}

// trusted root related configuration
type TrustRootConfig struct {
	// oranization ideftifier
	OrgId string `protobuf:"bytes,1,opt,name=org_id,json=orgId,proto3" json:"org_id,omitempty"`
	// root certificate / public key
	Root []string `protobuf:"bytes,2,rep,name=root,proto3" json:"root,omitempty"`
}

func (m *TrustRootConfig) Reset()         { *m = TrustRootConfig{} }
func (m *TrustRootConfig) String() string { return proto.CompactTextString(m) }
func (*TrustRootConfig) ProtoMessage()    {}
func (*TrustRootConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{10}
}
func (m *TrustRootConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrustRootConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrustRootConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrustRootConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrustRootConfig.Merge(m, src)
}
func (m *TrustRootConfig) XXX_Size() int {
	return m.Size()
}
func (m *TrustRootConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TrustRootConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TrustRootConfig proto.InternalMessageInfo

func (m *TrustRootConfig) GetOrgId() string {
	if m != nil {
		return m.OrgId
	}
	return ""
}

func (m *TrustRootConfig) GetRoot() []string {
	if m != nil {
		return m.Root
	}
	return nil
}

type ContractConfig struct {
	EnableSqlSupport bool `protobuf:"varint,1,opt,name=enable_sql_support,json=enableSqlSupport,proto3" json:"enable_sql_support,omitempty"`
}

func (m *ContractConfig) Reset()         { *m = ContractConfig{} }
func (m *ContractConfig) String() string { return proto.CompactTextString(m) }
func (*ContractConfig) ProtoMessage()    {}
func (*ContractConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{11}
}
func (m *ContractConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractConfig.Merge(m, src)
}
func (m *ContractConfig) XXX_Size() int {
	return m.Size()
}
func (m *ContractConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ContractConfig proto.InternalMessageInfo

func (m *ContractConfig) GetEnableSqlSupport() bool {
	if m != nil {
		return m.EnableSqlSupport
	}
	return false
}

// trusted member related configuration
type TrustMemberConfig struct {
	// member info
	MemberInfo string `protobuf:"bytes,1,opt,name=member_info,json=memberInfo,proto3" json:"member_info,omitempty"`
	// oranization ideftifier
	OrgId  string `protobuf:"bytes,2,opt,name=org_id,json=orgId,proto3" json:"org_id,omitempty"`
	Role   string `protobuf:"bytes,3,opt,name=role,proto3" json:"role,omitempty"`
	NodeId string `protobuf:"bytes,4,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *TrustMemberConfig) Reset()         { *m = TrustMemberConfig{} }
func (m *TrustMemberConfig) String() string { return proto.CompactTextString(m) }
func (*TrustMemberConfig) ProtoMessage()    {}
func (*TrustMemberConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a46c6a6ad69c864, []int{12}
}
func (m *TrustMemberConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrustMemberConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrustMemberConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrustMemberConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrustMemberConfig.Merge(m, src)
}
func (m *TrustMemberConfig) XXX_Size() int {
	return m.Size()
}
func (m *TrustMemberConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TrustMemberConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TrustMemberConfig proto.InternalMessageInfo

func (m *TrustMemberConfig) GetMemberInfo() string {
	if m != nil {
		return m.MemberInfo
	}
	return ""
}

func (m *TrustMemberConfig) GetOrgId() string {
	if m != nil {
		return m.OrgId
	}
	return ""
}

func (m *TrustMemberConfig) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *TrustMemberConfig) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func init() {
	proto.RegisterType((*ChainConfig)(nil), "config.ChainConfig")
	proto.RegisterType((*ResourcePolicy)(nil), "config.ResourcePolicy")
	proto.RegisterType((*CryptoConfig)(nil), "config.CryptoConfig")
	proto.RegisterType((*BlockConfig)(nil), "config.BlockConfig")
	proto.RegisterType((*SchedulerConfig)(nil), "config.SchedulerConfig")
	proto.RegisterType((*SnapshotConfig)(nil), "config.SnapshotConfig")
	proto.RegisterType((*ContextConfig)(nil), "config.ContextConfig")
	proto.RegisterType((*CoreConfig)(nil), "config.CoreConfig")
	proto.RegisterType((*ConsensusConfig)(nil), "config.ConsensusConfig")
	proto.RegisterType((*OrgConfig)(nil), "config.OrgConfig")
	proto.RegisterType((*TrustRootConfig)(nil), "config.TrustRootConfig")
	proto.RegisterType((*ContractConfig)(nil), "config.ContractConfig")
	proto.RegisterType((*TrustMemberConfig)(nil), "config.TrustMemberConfig")
}

func init() { proto.RegisterFile("config/chain_config.proto", fileDescriptor_2a46c6a6ad69c864) }

var fileDescriptor_2a46c6a6ad69c864 = []byte{
	// 969 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x36, 0x6d, 0x59, 0x3f, 0x23, 0x4b, 0x8a, 0x36, 0x4e, 0x42, 0xab, 0x88, 0x6a, 0xb0, 0x68,
	0xe3, 0x16, 0x8e, 0x54, 0x38, 0x28, 0x90, 0x16, 0x45, 0x80, 0x46, 0x28, 0x50, 0xa3, 0x68, 0x1b,
	0x50, 0xae, 0x0f, 0xbd, 0x10, 0x14, 0xb9, 0x96, 0x88, 0x50, 0x5c, 0x7a, 0x77, 0x29, 0x50, 0xb9,
	0xf5, 0x0d, 0xfa, 0x02, 0x7d, 0x99, 0x9e, 0x7a, 0x2a, 0x72, 0xec, 0xb1, 0xb0, 0x5f, 0xa4, 0xd8,
	0xd9, 0x25, 0x25, 0x3a, 0x08, 0x90, 0xdb, 0xce, 0x37, 0xdf, 0x37, 0xbb, 0x3b, 0x3b, 0x33, 0x0b,
	0x47, 0x01, 0x4b, 0xae, 0xa2, 0xf9, 0x38, 0x58, 0xf8, 0x51, 0xe2, 0x69, 0x63, 0x94, 0x72, 0x26,
	0x19, 0xa9, 0x6b, 0x6b, 0xa0, 0x28, 0x82, 0x26, 0x22, 0x13, 0xe3, 0x72, 0xa5, 0x29, 0x83, 0xc3,
	0x80, 0x2d, 0x97, 0x2c, 0x19, 0x73, 0x7a, 0x9d, 0x51, 0x21, 0x0d, 0x3a, 0xf0, 0x83, 0x80, 0x0a,
	0x11, 0xb0, 0x44, 0x72, 0x16, 0x8f, 0x53, 0x16, 0x47, 0xc1, 0x5a, 0xfb, 0x9c, 0xbf, 0xf6, 0xa1,
	0x3d, 0x51, 0x7b, 0x4d, 0x30, 0x38, 0x39, 0x82, 0xa6, 0xde, 0x3a, 0x0a, 0x6d, 0xeb, 0xd8, 0x3a,
	0x69, 0xb9, 0x0d, 0xb4, 0xcf, 0x43, 0x62, 0x43, 0x63, 0x45, 0xb9, 0x88, 0x58, 0x62, 0xef, 0x6a,
	0x8f, 0x31, 0xc9, 0x47, 0xd0, 0xf2, 0x33, 0xb9, 0xf0, 0xe4, 0x3a, 0xa5, 0xf6, 0x1e, 0xfa, 0x9a,
	0x0a, 0xb8, 0x58, 0xa7, 0x94, 0x0c, 0xa0, 0x29, 0xd4, 0x71, 0x92, 0x80, 0xda, 0xb5, 0x63, 0xeb,
	0xa4, 0xe6, 0x96, 0x36, 0x39, 0x85, 0x7a, 0xc0, 0xd7, 0xa9, 0x64, 0xf6, 0xfe, 0xb1, 0x75, 0xd2,
	0x3e, 0x3b, 0x1c, 0x99, 0x1b, 0x4f, 0x10, 0xd5, 0x67, 0x72, 0x0d, 0x87, 0x7c, 0x0e, 0xfb, 0xb3,
	0x98, 0x05, 0xaf, 0xed, 0x3a, 0x92, 0xef, 0x17, 0xe4, 0x97, 0x0a, 0x34, 0x5c, 0xcd, 0x20, 0x9f,
	0x41, 0x2d, 0x60, 0x9c, 0xda, 0x0d, 0x64, 0x92, 0x32, 0x2c, 0xe3, 0xd4, 0x10, 0xd1, 0x4f, 0xbe,
	0x82, 0x56, 0x99, 0x43, 0xbb, 0x89, 0xe4, 0x47, 0x1b, 0xb2, 0x71, 0x18, 0xc5, 0x86, 0x49, 0x9e,
	0x43, 0x5b, 0xf2, 0x4c, 0x48, 0x8f, 0x33, 0x26, 0x85, 0xdd, 0x3a, 0xde, 0xdb, 0x16, 0x5e, 0x28,
	0x97, 0xcb, 0x98, 0x34, 0x42, 0x90, 0x05, 0x20, 0xc8, 0x0b, 0xe8, 0x68, 0xe5, 0x92, 0x2e, 0x67,
	0x94, 0x0b, 0x1b, 0x50, 0x7b, 0x54, 0xd1, 0xfe, 0x84, 0x3e, 0xa3, 0x3e, 0x90, 0x1b, 0x48, 0x90,
	0x09, 0xf4, 0x39, 0x15, 0x2c, 0xe3, 0x01, 0xf5, 0xf0, 0x21, 0x23, 0x2a, 0xec, 0x36, 0xc6, 0x78,
	0x58, 0xc4, 0x70, 0x0d, 0xe1, 0x15, 0x3e, 0xb4, 0x7b, 0x8f, 0x6f, 0xdb, 0x11, 0x15, 0xe4, 0x0c,
	0x9a, 0x58, 0x0c, 0x7e, 0x20, 0xed, 0x03, 0xbc, 0xf4, 0xc3, 0xad, 0x4b, 0x23, 0x6e, 0x36, 0x2f,
	0x79, 0x4a, 0x23, 0x12, 0x3f, 0x15, 0x0b, 0x26, 0xed, 0x4e, 0x55, 0x33, 0x35, 0x78, 0xa1, 0x29,
	0x78, 0x2a, 0xbb, 0x22, 0x58, 0xd0, 0x30, 0x8b, 0x29, 0xb7, 0xbb, 0xd5, 0xec, 0x4e, 0x0b, 0x47,
	0x91, 0xdd, 0x92, 0x49, 0xc6, 0xd0, 0x50, 0xdb, 0xd2, 0x5c, 0xda, 0x3d, 0x14, 0x3d, 0xd8, 0x3e,
	0x1d, 0xcd, 0x8b, 0x8d, 0x0a, 0x96, 0x13, 0x42, 0xb7, 0x7a, 0x67, 0xf2, 0x09, 0x74, 0xca, 0x34,
	0x25, 0xfe, 0x92, 0x9a, 0x5a, 0x3e, 0x28, 0xc0, 0x9f, 0xfd, 0x25, 0x25, 0x4f, 0xa1, 0xae, 0x7b,
	0x01, 0xeb, 0x59, 0x6d, 0x53, 0x69, 0x94, 0x91, 0xc9, 0x9f, 0x21, 0x39, 0x0e, 0x1c, 0x6c, 0x97,
	0x25, 0x21, 0x50, 0x5b, 0xf8, 0x62, 0x61, 0x42, 0xe3, 0xda, 0xf9, 0xc7, 0x82, 0xf6, 0x56, 0x39,
	0x92, 0x11, 0xdc, 0x97, 0xb9, 0x27, 0xa3, 0x25, 0x15, 0xd2, 0x5f, 0xa6, 0xde, 0x8a, 0xf2, 0xe8,
	0x6a, 0x8d, 0x92, 0xa6, 0xdb, 0x97, 0xf9, 0x45, 0xe1, 0xb9, 0x44, 0x07, 0x79, 0x0c, 0x60, 0xf8,
	0x2c, 0x93, 0x78, 0xac, 0x8e, 0xdb, 0xd2, 0x34, 0x96, 0x49, 0xf2, 0x05, 0xf4, 0xb1, 0xbe, 0x3d,
	0x99, 0x7b, 0x81, 0x9f, 0xfa, 0x41, 0x24, 0xd7, 0xd8, 0x70, 0x1d, 0xb7, 0x87, 0x8e, 0x8b, 0x7c,
	0x62, 0x60, 0x15, 0x4a, 0x73, 0x45, 0xf4, 0x46, 0x77, 0x5e, 0xc7, 0x6d, 0x21, 0x32, 0x8d, 0xde,
	0x50, 0xf2, 0x29, 0x74, 0xb5, 0x3b, 0x4a, 0x24, 0xe5, 0x2b, 0x3f, 0xc6, 0x16, 0xec, 0xb8, 0x1d,
	0x44, 0xcf, 0x0d, 0xe8, 0x7c, 0x03, 0xbd, 0x3b, 0x2f, 0x45, 0x9e, 0x40, 0x8f, 0x26, 0xfe, 0x2c,
	0xa6, 0x1e, 0x5d, 0x45, 0x21, 0xf6, 0xb5, 0xbe, 0x4f, 0x57, 0xc3, 0xdf, 0x1b, 0xd4, 0xf9, 0x1a,
	0xba, 0xd5, 0xd2, 0xf8, 0x70, 0xe9, 0x73, 0xe8, 0x54, 0xde, 0xfa, 0xc3, 0x95, 0xbf, 0x5b, 0x00,
	0x9b, 0x36, 0x27, 0x5f, 0xc2, 0xa1, 0xcc, 0xbd, 0xb2, 0xb6, 0xca, 0xd4, 0x5a, 0x38, 0x89, 0x88,
	0xcc, 0xcb, 0xdb, 0x15, 0x39, 0xfe, 0x0e, 0x1e, 0x57, 0x14, 0x2b, 0x3f, 0x8e, 0x42, 0x5f, 0xd2,
	0xca, 0xab, 0xd4, 0xdc, 0xc1, 0x96, 0xf4, 0xd2, 0x50, 0x4c, 0x08, 0xe7, 0x4f, 0x0b, 0x7a, 0x77,
	0xa6, 0x07, 0x39, 0x85, 0x1a, 0x8e, 0x47, 0xb5, 0x71, 0xf7, 0xcc, 0x1e, 0x6d, 0x46, 0x77, 0xc9,
	0x54, 0xe3, 0xd2, 0x45, 0x16, 0x79, 0x02, 0xfb, 0x09, 0x0b, 0xa9, 0xb0, 0x77, 0xb1, 0xb5, 0xfb,
	0x45, 0x03, 0xfc, 0xc2, 0xe7, 0xc5, 0xa0, 0x43, 0x3f, 0x79, 0x06, 0x40, 0x73, 0x69, 0x3e, 0x0a,
	0x7b, 0x0f, 0xd9, 0x6a, 0x8a, 0xaa, 0x6f, 0x60, 0xf4, 0x23, 0x5d, 0x5f, 0xfa, 0x71, 0x46, 0x5f,
	0xf9, 0x11, 0x77, 0x5b, 0x65, 0x32, 0x9d, 0x5f, 0xa1, 0x55, 0x06, 0x22, 0x0f, 0xa0, 0xce, 0xf8,
	0x7c, 0x33, 0xef, 0xf7, 0x19, 0x9f, 0xeb, 0x69, 0xef, 0x87, 0x21, 0xa7, 0x42, 0x9f, 0xa1, 0xe5,
	0x16, 0x26, 0x79, 0x04, 0x0d, 0xb5, 0xb7, 0x52, 0xec, 0xa1, 0xa7, 0xae, 0xcc, 0xf3, 0xd0, 0xf9,
	0x16, 0x7a, 0x77, 0x46, 0xdf, 0xfb, 0x82, 0x13, 0xa8, 0xa9, 0xc9, 0x69, 0x22, 0xe3, 0xda, 0x79,
	0x01, 0xdd, 0xea, 0xf0, 0x21, 0xa7, 0x40, 0xcc, 0x9b, 0x8b, 0xeb, 0xd8, 0x13, 0x59, 0x9a, 0x32,
	0x2e, 0xcd, 0xb3, 0xdf, 0xd3, 0x9e, 0xe9, 0x75, 0x3c, 0xd5, 0xb8, 0x93, 0x43, 0xff, 0x9d, 0xe1,
	0x49, 0x3e, 0x86, 0xb6, 0x1e, 0xb4, 0x5e, 0x94, 0x5c, 0x31, 0x73, 0x08, 0xd0, 0xd0, 0x79, 0x72,
	0xc5, 0xb6, 0x0e, 0xb8, 0xfb, 0xce, 0x01, 0xe3, 0xe2, 0x33, 0xc3, 0xf5, 0xf6, 0xbd, 0x6b, 0x08,
	0x9b, 0x7b, 0xbf, 0xfc, 0xe1, 0xef, 0x9b, 0xa1, 0xf5, 0xf6, 0x66, 0x68, 0xfd, 0x77, 0x33, 0xb4,
	0xfe, 0xb8, 0x1d, 0xee, 0xbc, 0xbd, 0x1d, 0xee, 0xfc, 0x7b, 0x3b, 0xdc, 0xf9, 0x6d, 0x84, 0x7f,
	0xe7, 0xd2, 0x7f, 0x4d, 0xf9, 0x88, 0x71, 0xf3, 0xab, 0xa3, 0xf9, 0x74, 0xce, 0xc6, 0xe9, 0x6c,
	0x8c, 0x9f, 0xf0, 0x9c, 0x8d, 0xf5, 0xfb, 0xcd, 0xea, 0x68, 0x3f, 0xfb, 0x3f, 0x00, 0x00, 0xff,
	0xff, 0x47, 0xa8, 0x26, 0xe9, 0x06, 0x08, 0x00, 0x00,
}

func (m *ChainConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.Scheduler != nil {
		{
			size, err := m.Scheduler.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Snapshot != nil {
		{
			size, err := m.Snapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Contract != nil {
		{
			size, err := m.Contract.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.ResourcePolicies) > 0 {
		for iNdEx := len(m.ResourcePolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResourcePolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChainConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.TrustMembers) > 0 {
		for iNdEx := len(m.TrustMembers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrustMembers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChainConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.TrustRoots) > 0 {
		for iNdEx := len(m.TrustRoots) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrustRoots[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChainConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Consensus != nil {
		{
			size, err := m.Consensus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Core != nil {
		{
			size, err := m.Core.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Crypto != nil {
		{
			size, err := m.Crypto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Sequence != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AuthType) > 0 {
		i -= len(m.AuthType)
		copy(dAtA[i:], m.AuthType)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.AuthType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourcePolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourcePolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourcePolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ResourceName) > 0 {
		i -= len(m.ResourceName)
		copy(dAtA[i:], m.ResourceName)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.ResourceName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CryptoConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CryptoConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CryptoConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockInterval != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.BlockInterval))
		i--
		dAtA[i] = 0x28
	}
	if m.BlockSize != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.BlockSize))
		i--
		dAtA[i] = 0x20
	}
	if m.BlockTxCapacity != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.BlockTxCapacity))
		i--
		dAtA[i] = 0x18
	}
	if m.TxTimeout != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.TxTimeout))
		i--
		dAtA[i] = 0x10
	}
	if m.TxTimestampVerify {
		i--
		if m.TxTimestampVerify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SchedulerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedulerConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedulerConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableEvidence {
		i--
		if m.EnableEvidence {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableEvidence {
		i--
		if m.EnableEvidence {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContextConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContextConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContextConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableEvidence {
		i--
		if m.EnableEvidence {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CoreConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoreConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoreConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TxSchedulerValidateTimeout != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.TxSchedulerValidateTimeout))
		i--
		dAtA[i] = 0x10
	}
	if m.TxSchedulerTimeout != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.TxSchedulerTimeout))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExtConfig) > 0 {
		for iNdEx := len(m.ExtConfig) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExtConfig[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChainConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChainConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Type != 0 {
		i = encodeVarintChainConfig(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OrgConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrgConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrgConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		for iNdEx := len(m.NodeId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NodeId[iNdEx])
			copy(dAtA[i:], m.NodeId[iNdEx])
			i = encodeVarintChainConfig(dAtA, i, uint64(len(m.NodeId[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Address) > 0 {
		for iNdEx := len(m.Address) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Address[iNdEx])
			copy(dAtA[i:], m.Address[iNdEx])
			i = encodeVarintChainConfig(dAtA, i, uint64(len(m.Address[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.OrgId) > 0 {
		i -= len(m.OrgId)
		copy(dAtA[i:], m.OrgId)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.OrgId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TrustRootConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrustRootConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrustRootConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Root) > 0 {
		for iNdEx := len(m.Root) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Root[iNdEx])
			copy(dAtA[i:], m.Root[iNdEx])
			i = encodeVarintChainConfig(dAtA, i, uint64(len(m.Root[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.OrgId) > 0 {
		i -= len(m.OrgId)
		copy(dAtA[i:], m.OrgId)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.OrgId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableSqlSupport {
		i--
		if m.EnableSqlSupport {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TrustMemberConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrustMemberConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrustMemberConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OrgId) > 0 {
		i -= len(m.OrgId)
		copy(dAtA[i:], m.OrgId)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.OrgId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MemberInfo) > 0 {
		i -= len(m.MemberInfo)
		copy(dAtA[i:], m.MemberInfo)
		i = encodeVarintChainConfig(dAtA, i, uint64(len(m.MemberInfo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintChainConfig(dAtA []byte, offset int, v uint64) int {
	offset -= sovChainConfig(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ChainConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	l = len(m.AuthType)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovChainConfig(uint64(m.Sequence))
	}
	if m.Crypto != nil {
		l = m.Crypto.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if m.Core != nil {
		l = m.Core.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if m.Consensus != nil {
		l = m.Consensus.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if len(m.TrustRoots) > 0 {
		for _, e := range m.TrustRoots {
			l = e.Size()
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	if len(m.TrustMembers) > 0 {
		for _, e := range m.TrustMembers {
			l = e.Size()
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	if len(m.ResourcePolicies) > 0 {
		for _, e := range m.ResourcePolicies {
			l = e.Size()
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	if m.Contract != nil {
		l = m.Contract.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if m.Snapshot != nil {
		l = m.Snapshot.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if m.Scheduler != nil {
		l = m.Scheduler.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	return n
}

func (m *ResourcePolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceName)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovChainConfig(uint64(l))
	}
	return n
}

func (m *CryptoConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	return n
}

func (m *BlockConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxTimestampVerify {
		n += 2
	}
	if m.TxTimeout != 0 {
		n += 1 + sovChainConfig(uint64(m.TxTimeout))
	}
	if m.BlockTxCapacity != 0 {
		n += 1 + sovChainConfig(uint64(m.BlockTxCapacity))
	}
	if m.BlockSize != 0 {
		n += 1 + sovChainConfig(uint64(m.BlockSize))
	}
	if m.BlockInterval != 0 {
		n += 1 + sovChainConfig(uint64(m.BlockInterval))
	}
	return n
}

func (m *SchedulerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableEvidence {
		n += 2
	}
	return n
}

func (m *SnapshotConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableEvidence {
		n += 2
	}
	return n
}

func (m *ContextConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableEvidence {
		n += 2
	}
	return n
}

func (m *CoreConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxSchedulerTimeout != 0 {
		n += 1 + sovChainConfig(uint64(m.TxSchedulerTimeout))
	}
	if m.TxSchedulerValidateTimeout != 0 {
		n += 1 + sovChainConfig(uint64(m.TxSchedulerValidateTimeout))
	}
	return n
}

func (m *ConsensusConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovChainConfig(uint64(m.Type))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	if len(m.ExtConfig) > 0 {
		for _, e := range m.ExtConfig {
			l = e.Size()
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	return n
}

func (m *OrgConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrgId)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if len(m.Address) > 0 {
		for _, s := range m.Address {
			l = len(s)
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	if len(m.NodeId) > 0 {
		for _, s := range m.NodeId {
			l = len(s)
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	return n
}

func (m *TrustRootConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrgId)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	if len(m.Root) > 0 {
		for _, s := range m.Root {
			l = len(s)
			n += 1 + l + sovChainConfig(uint64(l))
		}
	}
	return n
}

func (m *ContractConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableSqlSupport {
		n += 2
	}
	return n
}

func (m *TrustMemberConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MemberInfo)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	l = len(m.OrgId)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovChainConfig(uint64(l))
	}
	return n
}

func sovChainConfig(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozChainConfig(x uint64) (n int) {
	return sovChainConfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ChainConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crypto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Crypto == nil {
				m.Crypto = &CryptoConfig{}
			}
			if err := m.Crypto.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &BlockConfig{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Core", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Core == nil {
				m.Core = &CoreConfig{}
			}
			if err := m.Core.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consensus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Consensus == nil {
				m.Consensus = &ConsensusConfig{}
			}
			if err := m.Consensus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustRoots", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustRoots = append(m.TrustRoots, &TrustRootConfig{})
			if err := m.TrustRoots[len(m.TrustRoots)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustMembers = append(m.TrustMembers, &TrustMemberConfig{})
			if err := m.TrustMembers[len(m.TrustMembers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourcePolicies = append(m.ResourcePolicies, &ResourcePolicy{})
			if err := m.ResourcePolicies[len(m.ResourcePolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Contract == nil {
				m.Contract = &ContractConfig{}
			}
			if err := m.Contract.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Snapshot == nil {
				m.Snapshot = &SnapshotConfig{}
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheduler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scheduler == nil {
				m.Scheduler = &SchedulerConfig{}
			}
			if err := m.Scheduler.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &ContextConfig{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourcePolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourcePolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourcePolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &accesscontrol.Policy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CryptoConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CryptoConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CryptoConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxTimestampVerify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TxTimestampVerify = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxTimeout", wireType)
			}
			m.TxTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTxCapacity", wireType)
			}
			m.BlockTxCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTxCapacity |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSize", wireType)
			}
			m.BlockSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockInterval", wireType)
			}
			m.BlockInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedulerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedulerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedulerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableEvidence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableEvidence = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableEvidence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableEvidence = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContextConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContextConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContextConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableEvidence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableEvidence = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoreConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoreConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoreConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxSchedulerTimeout", wireType)
			}
			m.TxSchedulerTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxSchedulerTimeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxSchedulerValidateTimeout", wireType)
			}
			m.TxSchedulerValidateTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxSchedulerValidateTimeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= consensus.ConsensusType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &OrgConfig{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtConfig = append(m.ExtConfig, &common.KeyValuePair{})
			if err := m.ExtConfig[len(m.ExtConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrgConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrgConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrgConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = append(m.NodeId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrustRootConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrustRootConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrustRootConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSqlSupport", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableSqlSupport = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrustMemberConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrustMemberConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrustMemberConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemberInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChainConfig(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChainConfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChainConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthChainConfig
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupChainConfig
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthChainConfig
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthChainConfig        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChainConfig          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupChainConfig = fmt.Errorf("proto: unexpected end of group")
)
