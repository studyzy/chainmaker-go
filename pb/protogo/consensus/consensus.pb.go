// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: consensus/consensus.proto

package consensus

import (
	common "chainmaker.org/chainmaker-go/pb/protogo/common"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ConsensusType int32

const (
	ConsensusType_SOLO     ConsensusType = 0
	ConsensusType_TBFT     ConsensusType = 1
	ConsensusType_MBFT     ConsensusType = 2
	ConsensusType_HOTSTUFF ConsensusType = 3
	ConsensusType_RAFT     ConsensusType = 4
	ConsensusType_POW      ConsensusType = 10
)

var ConsensusType_name = map[int32]string{
	0:  "SOLO",
	1:  "TBFT",
	2:  "MBFT",
	3:  "HOTSTUFF",
	4:  "RAFT",
	10: "POW",
}

var ConsensusType_value = map[string]int32{
	"SOLO":     0,
	"TBFT":     1,
	"MBFT":     2,
	"HOTSTUFF": 3,
	"RAFT":     4,
	"POW":      10,
}

func (x ConsensusType) String() string {
	return proto.EnumName(ConsensusType_name, int32(x))
}

func (ConsensusType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{0}
}

type VerifyResult_Code int32

const (
	VerifyResult_SUCCESS VerifyResult_Code = 0
	VerifyResult_FAIL    VerifyResult_Code = 1
)

var VerifyResult_Code_name = map[int32]string{
	0: "SUCCESS",
	1: "FAIL",
}

var VerifyResult_Code_value = map[string]int32{
	"SUCCESS": 0,
	"FAIL":    1,
}

func (x VerifyResult_Code) String() string {
	return proto.EnumName(VerifyResult_Code_name, int32(x))
}

func (VerifyResult_Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{0, 0}
}

type VerifyResult struct {
	VerifiedBlock *common.Block     `protobuf:"bytes,1,opt,name=verified_block,json=verifiedBlock,proto3" json:"verified_block,omitempty"`
	Code          VerifyResult_Code `protobuf:"varint,2,opt,name=code,proto3,enum=consensus.VerifyResult_Code" json:"code,omitempty"`
	Msg           string            `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *VerifyResult) Reset()         { *m = VerifyResult{} }
func (m *VerifyResult) String() string { return proto.CompactTextString(m) }
func (*VerifyResult) ProtoMessage()    {}
func (*VerifyResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{0}
}
func (m *VerifyResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyResult.Merge(m, src)
}
func (m *VerifyResult) XXX_Size() int {
	return m.Size()
}
func (m *VerifyResult) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyResult.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyResult proto.InternalMessageInfo

func (m *VerifyResult) GetVerifiedBlock() *common.Block {
	if m != nil {
		return m.VerifiedBlock
	}
	return nil
}

func (m *VerifyResult) GetCode() VerifyResult_Code {
	if m != nil {
		return m.Code
	}
	return VerifyResult_SUCCESS
}

func (m *VerifyResult) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type BlockHeaderConsensusArgs struct {
	ConsensusType int64 `protobuf:"varint,1,opt,name=ConsensusType,proto3" json:"ConsensusType,omitempty"`
	// bytes ConsensusData = 2;
	Round         uint64          `protobuf:"varint,3,opt,name=Round,proto3" json:"Round,omitempty"`
	Level         uint64          `protobuf:"varint,4,opt,name=Level,proto3" json:"Level,omitempty"`
	ConsensusData *common.TxRWSet `protobuf:"bytes,5,opt,name=ConsensusData,proto3" json:"ConsensusData,omitempty"`
}

func (m *BlockHeaderConsensusArgs) Reset()         { *m = BlockHeaderConsensusArgs{} }
func (m *BlockHeaderConsensusArgs) String() string { return proto.CompactTextString(m) }
func (*BlockHeaderConsensusArgs) ProtoMessage()    {}
func (*BlockHeaderConsensusArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{1}
}
func (m *BlockHeaderConsensusArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockHeaderConsensusArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockHeaderConsensusArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockHeaderConsensusArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockHeaderConsensusArgs.Merge(m, src)
}
func (m *BlockHeaderConsensusArgs) XXX_Size() int {
	return m.Size()
}
func (m *BlockHeaderConsensusArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockHeaderConsensusArgs.DiscardUnknown(m)
}

var xxx_messageInfo_BlockHeaderConsensusArgs proto.InternalMessageInfo

func (m *BlockHeaderConsensusArgs) GetConsensusType() int64 {
	if m != nil {
		return m.ConsensusType
	}
	return 0
}

func (m *BlockHeaderConsensusArgs) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *BlockHeaderConsensusArgs) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *BlockHeaderConsensusArgs) GetConsensusData() *common.TxRWSet {
	if m != nil {
		return m.ConsensusData
	}
	return nil
}

type GovernanceMember struct {
	NodeID string `protobuf:"bytes,1,opt,name=NodeID,proto3" json:"NodeID,omitempty"`
	Index  int64  `protobuf:"varint,2,opt,name=Index,proto3" json:"Index,omitempty"`
}

func (m *GovernanceMember) Reset()         { *m = GovernanceMember{} }
func (m *GovernanceMember) String() string { return proto.CompactTextString(m) }
func (*GovernanceMember) ProtoMessage()    {}
func (*GovernanceMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{2}
}
func (m *GovernanceMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GovernanceMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GovernanceMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GovernanceMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GovernanceMember.Merge(m, src)
}
func (m *GovernanceMember) XXX_Size() int {
	return m.Size()
}
func (m *GovernanceMember) XXX_DiscardUnknown() {
	xxx_messageInfo_GovernanceMember.DiscardUnknown(m)
}

var xxx_messageInfo_GovernanceMember proto.InternalMessageInfo

func (m *GovernanceMember) GetNodeID() string {
	if m != nil {
		return m.NodeID
	}
	return ""
}

func (m *GovernanceMember) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

type GovernanceContract struct {
	EpochId           uint64        `protobuf:"varint,1,opt,name=EpochId,proto3" json:"EpochId,omitempty"`
	Type              ConsensusType `protobuf:"varint,2,opt,name=Type,proto3,enum=consensus.ConsensusType" json:"Type,omitempty"`
	CurMaxIndex       int64         `protobuf:"varint,3,opt,name=CurMaxIndex,proto3" json:"CurMaxIndex,omitempty"`
	SkipTimeoutCommit bool          `protobuf:"varint,4,opt,name=SkipTimeoutCommit,proto3" json:"SkipTimeoutCommit,omitempty"`
	//bool IsConfigChg = 4;   //is the configuration changed
	//bool IsValidatorChg = 5;    //is the validator changed
	ConfigSequence     uint64              `protobuf:"varint,6,opt,name=ConfigSequence,proto3" json:"ConfigSequence,omitempty"`
	N                  uint64              `protobuf:"varint,7,opt,name=N,proto3" json:"N,omitempty"`
	MinQuorumForQc     uint64              `protobuf:"varint,8,opt,name=MinQuorumForQc,proto3" json:"MinQuorumForQc,omitempty"`
	CachedLen          uint64              `protobuf:"varint,9,opt,name=CachedLen,proto3" json:"CachedLen,omitempty"`
	NextSwitchHeight   uint64              `protobuf:"varint,10,opt,name=NextSwitchHeight,proto3" json:"NextSwitchHeight,omitempty"`
	TransitBlock       uint64              `protobuf:"varint,11,opt,name=TransitBlock,proto3" json:"TransitBlock,omitempty"`
	BlockNumPerEpoch   uint64              `protobuf:"varint,12,opt,name=BlockNumPerEpoch,proto3" json:"BlockNumPerEpoch,omitempty"`
	ValidatorNum       uint64              `protobuf:"varint,13,opt,name=ValidatorNum,proto3" json:"ValidatorNum,omitempty"`
	NodeProposeRound   uint64              `protobuf:"varint,14,opt,name=NodeProposeRound,proto3" json:"NodeProposeRound,omitempty"`
	Members            []*GovernanceMember `protobuf:"bytes,15,rep,name=Members,proto3" json:"Members,omitempty"`
	Validators         []*GovernanceMember `protobuf:"bytes,16,rep,name=Validators,proto3" json:"Validators,omitempty"`
	NextValidators     []*GovernanceMember `protobuf:"bytes,17,rep,name=NextValidators,proto3" json:"NextValidators,omitempty"`
	LastMinQuorumForQc uint64              `protobuf:"varint,18,opt,name=LastMinQuorumForQc,proto3" json:"LastMinQuorumForQc,omitempty"`
}

func (m *GovernanceContract) Reset()         { *m = GovernanceContract{} }
func (m *GovernanceContract) String() string { return proto.CompactTextString(m) }
func (*GovernanceContract) ProtoMessage()    {}
func (*GovernanceContract) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{3}
}
func (m *GovernanceContract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GovernanceContract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GovernanceContract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GovernanceContract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GovernanceContract.Merge(m, src)
}
func (m *GovernanceContract) XXX_Size() int {
	return m.Size()
}
func (m *GovernanceContract) XXX_DiscardUnknown() {
	xxx_messageInfo_GovernanceContract.DiscardUnknown(m)
}

var xxx_messageInfo_GovernanceContract proto.InternalMessageInfo

func (m *GovernanceContract) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

func (m *GovernanceContract) GetType() ConsensusType {
	if m != nil {
		return m.Type
	}
	return ConsensusType_SOLO
}

func (m *GovernanceContract) GetCurMaxIndex() int64 {
	if m != nil {
		return m.CurMaxIndex
	}
	return 0
}

func (m *GovernanceContract) GetSkipTimeoutCommit() bool {
	if m != nil {
		return m.SkipTimeoutCommit
	}
	return false
}

func (m *GovernanceContract) GetConfigSequence() uint64 {
	if m != nil {
		return m.ConfigSequence
	}
	return 0
}

func (m *GovernanceContract) GetN() uint64 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *GovernanceContract) GetMinQuorumForQc() uint64 {
	if m != nil {
		return m.MinQuorumForQc
	}
	return 0
}

func (m *GovernanceContract) GetCachedLen() uint64 {
	if m != nil {
		return m.CachedLen
	}
	return 0
}

func (m *GovernanceContract) GetNextSwitchHeight() uint64 {
	if m != nil {
		return m.NextSwitchHeight
	}
	return 0
}

func (m *GovernanceContract) GetTransitBlock() uint64 {
	if m != nil {
		return m.TransitBlock
	}
	return 0
}

func (m *GovernanceContract) GetBlockNumPerEpoch() uint64 {
	if m != nil {
		return m.BlockNumPerEpoch
	}
	return 0
}

func (m *GovernanceContract) GetValidatorNum() uint64 {
	if m != nil {
		return m.ValidatorNum
	}
	return 0
}

func (m *GovernanceContract) GetNodeProposeRound() uint64 {
	if m != nil {
		return m.NodeProposeRound
	}
	return 0
}

func (m *GovernanceContract) GetMembers() []*GovernanceMember {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *GovernanceContract) GetValidators() []*GovernanceMember {
	if m != nil {
		return m.Validators
	}
	return nil
}

func (m *GovernanceContract) GetNextValidators() []*GovernanceMember {
	if m != nil {
		return m.NextValidators
	}
	return nil
}

func (m *GovernanceContract) GetLastMinQuorumForQc() uint64 {
	if m != nil {
		return m.LastMinQuorumForQc
	}
	return 0
}

func init() {
	proto.RegisterEnum("consensus.ConsensusType", ConsensusType_name, ConsensusType_value)
	proto.RegisterEnum("consensus.VerifyResult_Code", VerifyResult_Code_name, VerifyResult_Code_value)
	proto.RegisterType((*VerifyResult)(nil), "consensus.VerifyResult")
	proto.RegisterType((*BlockHeaderConsensusArgs)(nil), "consensus.BlockHeaderConsensusArgs")
	proto.RegisterType((*GovernanceMember)(nil), "consensus.GovernanceMember")
	proto.RegisterType((*GovernanceContract)(nil), "consensus.GovernanceContract")
}

func init() { proto.RegisterFile("consensus/consensus.proto", fileDescriptor_477fc6492de41e15) }

var fileDescriptor_477fc6492de41e15 = []byte{
	// 726 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x94, 0xcf, 0x4e, 0xfb, 0x46,
	0x10, 0xc7, 0xe3, 0x9f, 0x0d, 0x49, 0x26, 0x7f, 0x30, 0xab, 0xaa, 0xda, 0xb6, 0x34, 0x8a, 0xa2,
	0xaa, 0x8a, 0x10, 0x4d, 0x5a, 0x5a, 0x4e, 0xbd, 0x14, 0x0c, 0x29, 0x51, 0xf3, 0x07, 0xd6, 0x06,
	0xa4, 0x5e, 0x2a, 0xc7, 0x1e, 0x12, 0x8b, 0xd8, 0x9b, 0xae, 0x6d, 0x08, 0x6f, 0xd1, 0x77, 0xe8,
	0xa1, 0xaf, 0xd2, 0x23, 0xc7, 0x5e, 0x2a, 0x55, 0xf0, 0x22, 0x95, 0xd7, 0x24, 0x71, 0xc2, 0x4f,
	0xe2, 0x36, 0xf3, 0x99, 0x99, 0xef, 0xcc, 0x8e, 0x77, 0x0d, 0x9f, 0x39, 0x3c, 0x08, 0x31, 0x08,
	0xe3, 0xb0, 0xbd, 0xb4, 0x5a, 0x33, 0xc1, 0x23, 0x4e, 0x8a, 0x4b, 0xf0, 0x39, 0x71, 0xb8, 0xef,
	0xf3, 0xa0, 0x3d, 0x9a, 0x72, 0xe7, 0x2e, 0x0d, 0x2f, 0x99, 0x78, 0x08, 0x31, 0x4a, 0x59, 0xe3,
	0x2f, 0x05, 0xca, 0xd7, 0x28, 0xbc, 0xdb, 0x47, 0x86, 0x61, 0x3c, 0x8d, 0xc8, 0x0f, 0x50, 0xbd,
	0x4f, 0x7c, 0x0f, 0xdd, 0xdf, 0x64, 0x31, 0x55, 0xea, 0x4a, 0xb3, 0x74, 0x58, 0x69, 0xa5, 0xd5,
	0xad, 0x93, 0x04, 0xb2, 0xca, 0x22, 0x49, 0xba, 0xe4, 0x5b, 0xd0, 0x1c, 0xee, 0x22, 0xfd, 0x50,
	0x57, 0x9a, 0xd5, 0xc3, 0xbd, 0xd6, 0x6a, 0xb2, 0xac, 0x78, 0xcb, 0xe0, 0x2e, 0x32, 0x99, 0x49,
	0x74, 0x50, 0xfd, 0x70, 0x4c, 0xd5, 0xba, 0xd2, 0x2c, 0xb2, 0xc4, 0x6c, 0x7c, 0x09, 0x5a, 0x12,
	0x27, 0x25, 0xc8, 0x9b, 0x57, 0x86, 0x71, 0x66, 0x9a, 0x7a, 0x8e, 0x14, 0x40, 0xeb, 0x1c, 0x77,
	0x7b, 0xba, 0xd2, 0xf8, 0x53, 0x01, 0x2a, 0x9b, 0x9d, 0xa3, 0xed, 0xa2, 0x30, 0x16, 0x1d, 0x8e,
	0xc5, 0x38, 0x24, 0x5f, 0x41, 0x65, 0x09, 0xac, 0xc7, 0x19, 0xca, 0xa1, 0x55, 0xb6, 0x0e, 0xc9,
	0x27, 0xb0, 0xc5, 0x78, 0x1c, 0xb8, 0xb2, 0xab, 0xc6, 0x52, 0x27, 0xa1, 0x3d, 0xbc, 0xc7, 0x29,
	0xd5, 0x52, 0x2a, 0x1d, 0x72, 0x94, 0x51, 0x3c, 0xb5, 0x23, 0x9b, 0x6e, 0xc9, 0x35, 0xec, 0x2c,
	0xd6, 0x60, 0xcd, 0xd9, 0x8d, 0x89, 0x11, 0x5b, 0xcf, 0x6a, 0xfc, 0x04, 0xfa, 0xcf, 0xfc, 0x1e,
	0x45, 0x60, 0x07, 0x0e, 0xf6, 0xd1, 0x1f, 0xa1, 0x20, 0x9f, 0xc2, 0xf6, 0x80, 0xbb, 0xd8, 0x3d,
	0x95, 0x53, 0x15, 0xd9, 0xab, 0x97, 0x34, 0xee, 0x06, 0x2e, 0xce, 0xe5, 0xd6, 0x54, 0x96, 0x3a,
	0x8d, 0x7f, 0xb7, 0x80, 0xac, 0x24, 0x0c, 0x1e, 0x44, 0xc2, 0x76, 0x22, 0x42, 0x21, 0x7f, 0x36,
	0xe3, 0xce, 0xa4, 0xeb, 0x4a, 0x15, 0x8d, 0x2d, 0x5c, 0x72, 0x00, 0x9a, 0x3c, 0x72, 0xba, 0x7b,
	0x9a, 0xd9, 0xfd, 0xda, 0xe9, 0x99, 0xcc, 0x22, 0x75, 0x28, 0x19, 0xb1, 0xe8, 0xdb, 0xf3, 0xb4,
	0xb5, 0x2a, 0x5b, 0x67, 0x11, 0x39, 0x80, 0x5d, 0xf3, 0xce, 0x9b, 0x59, 0x9e, 0x8f, 0x3c, 0x8e,
	0x0c, 0xee, 0xfb, 0x5e, 0x24, 0x77, 0x53, 0x60, 0x6f, 0x03, 0xe4, 0x6b, 0xa8, 0x1a, 0x3c, 0xb8,
	0xf5, 0xc6, 0x26, 0xfe, 0x1e, 0x63, 0xe0, 0x20, 0xdd, 0x96, 0xe3, 0x6d, 0x50, 0x52, 0x06, 0x65,
	0x40, 0xf3, 0x32, 0xa4, 0x0c, 0x92, 0xaa, 0xbe, 0x17, 0x5c, 0xc6, 0x5c, 0xc4, 0x7e, 0x87, 0x8b,
	0x4b, 0x87, 0x16, 0xd2, 0xaa, 0x75, 0x4a, 0xf6, 0xa0, 0x68, 0xd8, 0xce, 0x04, 0xdd, 0x1e, 0x06,
	0xb4, 0x28, 0x53, 0x56, 0x80, 0xec, 0x83, 0x3e, 0xc0, 0x79, 0x64, 0x3e, 0x78, 0x91, 0x33, 0x39,
	0x47, 0x6f, 0x3c, 0x89, 0x28, 0xc8, 0xa4, 0x37, 0x9c, 0x34, 0xa0, 0x6c, 0x09, 0x3b, 0x08, 0xbd,
	0x48, 0x5e, 0x22, 0x5a, 0x92, 0x79, 0x6b, 0x2c, 0xd1, 0x93, 0xc6, 0x20, 0xf6, 0x2f, 0x50, 0xc8,
	0xfd, 0xd2, 0x72, 0xaa, 0xb7, 0xc9, 0x13, 0xbd, 0x6b, 0x7b, 0xea, 0xb9, 0x76, 0xc4, 0xc5, 0x20,
	0xf6, 0x69, 0x25, 0xd5, 0xcb, 0x32, 0x39, 0x1f, 0x77, 0xf1, 0x42, 0xf0, 0x19, 0x0f, 0x31, 0xbd,
	0x7a, 0xd5, 0xd7, 0xf9, 0x36, 0x38, 0x39, 0x82, 0x7c, 0x7a, 0x5d, 0x42, 0xba, 0x53, 0x57, 0x9b,
	0xa5, 0xc3, 0x2f, 0x32, 0x1f, 0x72, 0xf3, 0x4a, 0xb1, 0x45, 0x2e, 0xf9, 0x11, 0x60, 0xd9, 0x32,
	0xa4, 0xfa, 0xfb, 0x95, 0x99, 0x74, 0x62, 0x40, 0x35, 0xd9, 0x53, 0x46, 0x60, 0xf7, 0x7d, 0x81,
	0x8d, 0x12, 0xd2, 0x02, 0xd2, 0xb3, 0xc3, 0x68, 0xe3, 0x73, 0x12, 0x79, 0xcc, 0x8f, 0x44, 0xf6,
	0x07, 0x1b, 0x4f, 0x35, 0x79, 0xe2, 0xe6, 0xb0, 0x37, 0x4c, 0x1f, 0xbb, 0x75, 0xd2, 0xb1, 0x74,
	0x25, 0xb1, 0xfa, 0x89, 0xf5, 0x81, 0x94, 0xa1, 0x70, 0x3e, 0xb4, 0x4c, 0xeb, 0xaa, 0xd3, 0xd1,
	0xd5, 0x84, 0xb3, 0xe3, 0x8e, 0xa5, 0x6b, 0x24, 0x0f, 0xea, 0xc5, 0xf0, 0x46, 0x87, 0x93, 0x5f,
	0xfe, 0x7e, 0xae, 0x29, 0x4f, 0xcf, 0x35, 0xe5, 0xbf, 0xe7, 0x9a, 0xf2, 0xc7, 0x4b, 0x2d, 0xf7,
	0xf4, 0x52, 0xcb, 0xfd, 0xf3, 0x52, 0xcb, 0xfd, 0xfa, 0x9d, 0x33, 0xb1, 0xbd, 0xc0, 0xb7, 0xef,
	0x50, 0xb4, 0xb8, 0x18, 0xb7, 0x57, 0xee, 0x37, 0x63, 0xde, 0x9e, 0x8d, 0xda, 0xf2, 0x17, 0x38,
	0xe6, 0xab, 0xff, 0xe8, 0x68, 0x5b, 0xa2, 0xef, 0xff, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x02, 0xb5,
	0x22, 0xf0, 0x65, 0x05, 0x00, 0x00,
}

func (m *VerifyResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.VerifiedBlock != nil {
		{
			size, err := m.VerifiedBlock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockHeaderConsensusArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockHeaderConsensusArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockHeaderConsensusArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConsensusData != nil {
		{
			size, err := m.ConsensusData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Level != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x20
	}
	if m.Round != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x18
	}
	if m.ConsensusType != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.ConsensusType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GovernanceMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GovernanceMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GovernanceMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeID) > 0 {
		i -= len(m.NodeID)
		copy(dAtA[i:], m.NodeID)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.NodeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GovernanceContract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GovernanceContract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GovernanceContract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastMinQuorumForQc != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.LastMinQuorumForQc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.NextValidators) > 0 {
		for iNdEx := len(m.NextValidators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NextValidators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintConsensus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.Validators) > 0 {
		for iNdEx := len(m.Validators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Validators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintConsensus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintConsensus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.NodeProposeRound != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.NodeProposeRound))
		i--
		dAtA[i] = 0x70
	}
	if m.ValidatorNum != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.ValidatorNum))
		i--
		dAtA[i] = 0x68
	}
	if m.BlockNumPerEpoch != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.BlockNumPerEpoch))
		i--
		dAtA[i] = 0x60
	}
	if m.TransitBlock != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.TransitBlock))
		i--
		dAtA[i] = 0x58
	}
	if m.NextSwitchHeight != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.NextSwitchHeight))
		i--
		dAtA[i] = 0x50
	}
	if m.CachedLen != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.CachedLen))
		i--
		dAtA[i] = 0x48
	}
	if m.MinQuorumForQc != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.MinQuorumForQc))
		i--
		dAtA[i] = 0x40
	}
	if m.N != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.N))
		i--
		dAtA[i] = 0x38
	}
	if m.ConfigSequence != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.ConfigSequence))
		i--
		dAtA[i] = 0x30
	}
	if m.SkipTimeoutCommit {
		i--
		if m.SkipTimeoutCommit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.CurMaxIndex != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.CurMaxIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.EpochId != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintConsensus(dAtA []byte, offset int, v uint64) int {
	offset -= sovConsensus(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *VerifyResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VerifiedBlock != nil {
		l = m.VerifiedBlock.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovConsensus(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}

func (m *BlockHeaderConsensusArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsensusType != 0 {
		n += 1 + sovConsensus(uint64(m.ConsensusType))
	}
	if m.Round != 0 {
		n += 1 + sovConsensus(uint64(m.Round))
	}
	if m.Level != 0 {
		n += 1 + sovConsensus(uint64(m.Level))
	}
	if m.ConsensusData != nil {
		l = m.ConsensusData.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}

func (m *GovernanceMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovConsensus(uint64(m.Index))
	}
	return n
}

func (m *GovernanceContract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochId != 0 {
		n += 1 + sovConsensus(uint64(m.EpochId))
	}
	if m.Type != 0 {
		n += 1 + sovConsensus(uint64(m.Type))
	}
	if m.CurMaxIndex != 0 {
		n += 1 + sovConsensus(uint64(m.CurMaxIndex))
	}
	if m.SkipTimeoutCommit {
		n += 2
	}
	if m.ConfigSequence != 0 {
		n += 1 + sovConsensus(uint64(m.ConfigSequence))
	}
	if m.N != 0 {
		n += 1 + sovConsensus(uint64(m.N))
	}
	if m.MinQuorumForQc != 0 {
		n += 1 + sovConsensus(uint64(m.MinQuorumForQc))
	}
	if m.CachedLen != 0 {
		n += 1 + sovConsensus(uint64(m.CachedLen))
	}
	if m.NextSwitchHeight != 0 {
		n += 1 + sovConsensus(uint64(m.NextSwitchHeight))
	}
	if m.TransitBlock != 0 {
		n += 1 + sovConsensus(uint64(m.TransitBlock))
	}
	if m.BlockNumPerEpoch != 0 {
		n += 1 + sovConsensus(uint64(m.BlockNumPerEpoch))
	}
	if m.ValidatorNum != 0 {
		n += 1 + sovConsensus(uint64(m.ValidatorNum))
	}
	if m.NodeProposeRound != 0 {
		n += 1 + sovConsensus(uint64(m.NodeProposeRound))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovConsensus(uint64(l))
		}
	}
	if len(m.Validators) > 0 {
		for _, e := range m.Validators {
			l = e.Size()
			n += 2 + l + sovConsensus(uint64(l))
		}
	}
	if len(m.NextValidators) > 0 {
		for _, e := range m.NextValidators {
			l = e.Size()
			n += 2 + l + sovConsensus(uint64(l))
		}
	}
	if m.LastMinQuorumForQc != 0 {
		n += 2 + sovConsensus(uint64(m.LastMinQuorumForQc))
	}
	return n
}

func sovConsensus(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozConsensus(x uint64) (n int) {
	return sovConsensus(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *VerifyResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifiedBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VerifiedBlock == nil {
				m.VerifiedBlock = &common.Block{}
			}
			if err := m.VerifiedBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= VerifyResult_Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockHeaderConsensusArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockHeaderConsensusArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockHeaderConsensusArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusType", wireType)
			}
			m.ConsensusType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsensusType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConsensusData == nil {
				m.ConsensusData = &common.TxRWSet{}
			}
			if err := m.ConsensusData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GovernanceMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GovernanceMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GovernanceMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GovernanceContract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GovernanceContract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GovernanceContract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ConsensusType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurMaxIndex", wireType)
			}
			m.CurMaxIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurMaxIndex |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipTimeoutCommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipTimeoutCommit = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigSequence", wireType)
			}
			m.ConfigSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigSequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuorumForQc", wireType)
			}
			m.MinQuorumForQc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinQuorumForQc |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedLen", wireType)
			}
			m.CachedLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CachedLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSwitchHeight", wireType)
			}
			m.NextSwitchHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextSwitchHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransitBlock", wireType)
			}
			m.TransitBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransitBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumPerEpoch", wireType)
			}
			m.BlockNumPerEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumPerEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorNum", wireType)
			}
			m.ValidatorNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidatorNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeProposeRound", wireType)
			}
			m.NodeProposeRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeProposeRound |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &GovernanceMember{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, &GovernanceMember{})
			if err := m.Validators[len(m.Validators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextValidators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextValidators = append(m.NextValidators, &GovernanceMember{})
			if err := m.NextValidators[len(m.NextValidators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMinQuorumForQc", wireType)
			}
			m.LastMinQuorumForQc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastMinQuorumForQc |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipConsensus(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthConsensus
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupConsensus
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthConsensus
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthConsensus        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowConsensus          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupConsensus = fmt.Errorf("proto: unexpected end of group")
)
